---
title: "Project 2 Data Cleaning and Preprocessing"
output: html_notebook
---

```{r}
install.packages("shiny")
library(shiny)  # Shiny framework for building interactive web apps
library(dplyr)  # Data manipulation package
library(tidyr)  # Data tidying functions
library(janitor)  # Cleaning column names
library(DT)  # Data tables for displaying output
library(readxl)  # Reading Excel files
library(stringr)  # String manipulation
library(lubridate)  # Date handling
library(jsonlite)  # Reading JSON files
library(arrow)  # File format support for advanced data storage

fileInput("file", "Upload Dataset", accept = c(".csv", ".xlsx", ".json", ".rds"))

raw_data <- reactive({
    req(input$file)  # Ensure file is uploaded
    ext <- tools::file_ext(input$file$datapath) #getting the file extensions, input$file$datapath refers to the path where the uploaded file is temporarily stored on the server 
    if (ext == "csv") {
        return(read.csv(input$file$datapath, stringsAsFactors = FALSE)) #loading different file formats 
    } else if (ext == "xlsx") {
        return(readxl::read_excel(input$file$datapath))
    } else if (ext == "json") {
        return(jsonlite::fromJSON(input$file$datapath))
    } else if (ext == "rds") {
        return(readRDS(input$file$datapath))
    } else {
        return(NULL) #handling unsupported file formats 
    }
})

observeEvent(input$sample_data, {
    if (input$sample_data == "mtcars") {
        raw_data(mtcars)
    } else if (input$sample_data == "iris") {
        raw_data(iris)
    }
})

output$raw_data <- renderDT({ raw_data() })


# Define the User Interface (UI)
ui <- fluidPage(
  titlePanel("Data Cleaning & Preprocessing"),
  sidebarLayout(
    sidebarPanel(
      fileInput("file", "Upload File", accept = c(".csv", ".xlsx", ".json", ".rds")),  # File upload
      checkboxGroupInput("clean_options", "Select Cleaning Steps:",  # Options for cleaning data
                         choices = list(
                           "Standardize Column Names" = "standardize",  # Convert column names to lowercase with underscores
                           "Remove Duplicates" = "remove_dupes",  # Remove duplicate rows
                           "Handle Missing Values (Mean Imputation)" = "impute_mean",  # Fill missing values with mean
                           "Handle Missing Values (Median Imputation)" = "impute_median",  # Fill missing values with median
                           "Trim Whitespace" = "trim_whitespace",  # Remove leading and trailing whitespace
                           "Convert Text to Lowercase" = "lowercase_text",  # Convert text columns to lowercase
                           "Convert Dates to Standard Format" = "convert_dates",  # Ensure dates are in YYYY-MM-DD format
                           "Remove Special Characters from Text" = "remove_special_chars",  # Remove non-alphanumeric characters
                           "Remove Outliers (Z-score > 3)" = "remove_outliers",  # Filter out numeric outliers
                           "Scale Numeric Variables" = "scale_numeric",  # Standardize numerical values
                           "One-Hot Encode Categorical Variables" = "one_hot_encode",  # Convert categorical values into binary variables
                           "Normalize Numeric Variables" = "normalize_numeric",  # Scale data between 0 and 1
                           "Log Transform Numeric Variables" = "log_transform",  # Apply logarithm transformation
                           "Replace Outliers with Mean" = "replace_outliers",  # Replace outliers with the mean
                           "Encode Ordinal Variables" = "encode_ordinal",  # Convert ordered categorical variables to numeric
                           "Drop Columns with High Missing Values" = "drop_high_na",  # Remove columns with excessive missing values
                           "Fix Inconsistent Categorical Labels" = "fix_categorical",  # Standardize category labels
                           "Extract Features from Date" = "extract_date_features"  # Extract year, month, day from date
                         )),
      actionButton("apply_cleaning", "Apply Cleaning")  # Button to apply cleaning steps
    ),
    mainPanel(
      DTOutput("cleaned_data")  # Display cleaned data
    )
  )
)

# Define Server Logic
server <- function(input, output, session) {
  data <- reactiveVal()

  # File Upload Handling
  observeEvent(input$file, {
    req(input$file)
    ext <- tools::file_ext(input$file$name)
    if (ext == "csv") {
      df <- read.csv(input$file$datapath, stringsAsFactors = FALSE)
    } else if (ext == "xlsx") {
      df <- read_excel(input$file$datapath)
    } else if (ext == "json") {
      df <- fromJSON(input$file$datapath, flatten = TRUE) %>% as.data.frame()
    } else if (ext == "rds") {
      df <- readRDS(input$file$datapath)
    } else {
      showNotification("Unsupported file format!", type = "error")
      return()
    }
    data(df)
  })

  # Data Cleaning Operations
  cleaned_data <- eventReactive(input$apply_cleaning, {
    req(data())
    df <- data()
    
    if ("standardize" %in% input$clean_options) {
      df <- df %>% clean_names()
    }
    
    if ("remove_dupes" %in% input$clean_options) {
      df <- df %>% distinct()
    }
    
    if ("impute_mean" %in% input$clean_options) {
      df <- df %>% mutate(across(where(is.numeric), ~replace_na(.x, mean(.x, na.rm = TRUE))))
    }
    
    if ("impute_median" %in% input$clean_options) {
      df <- df %>% mutate(across(where(is.numeric), ~replace_na(.x, median(.x, na.rm = TRUE))))
    }
    
    if ("trim_whitespace" %in% input$clean_options) {
      df <- df %>% mutate(across(where(is.character), str_trim))
    }
    
    if ("lowercase_text" %in% input$clean_options) {
      df <- df %>% mutate(across(where(is.character), tolower))
    }
    
    if ("convert_dates" %in% input$clean_options) {
      df <- df %>% mutate(across(where(is.character), ~if_else(!is.na(as.Date(.x, format = "%Y-%m-%d")), as.Date(.x, format = "%Y-%m-%d"), .x)))
    }
    
    if ("remove_special_chars" %in% input$clean_options) {
      df <- df %>% mutate(across(where(is.character), ~gsub("[^A-Za-z0-9 ]", "", .x)))
    }
    
    if ("remove_outliers" %in% input$clean_options) {
      df <- df %>% filter(across(where(is.numeric), ~ abs(scale(.x)) < 3))
    }
    
    if ("scale_numeric" %in% input$clean_options) {
      df <- df %>% mutate(across(where(is.numeric), scale))
    }
    
    if ("normalize_numeric" %in% input$clean_options) {
      df <- df %>% mutate(across(where(is.numeric), ~ (.x - min(.x, na.rm = TRUE)) / (max(.x, na.rm = TRUE) - min(.x, na.rm = TRUE))))
    }
    
    if ("log_transform" %in% input$clean_options) {
      df <- df %>% mutate(across(where(is.numeric), ~ ifelse(.x > 0, log(.x), .x)))
    }
    
    if ("replace_outliers" %in% input$clean_options) {
      df <- df %>% mutate(across(where(is.numeric), ~ ifelse(abs(scale(.x)) > 3, mean(.x, na.rm = TRUE), .x)))
    }
    
    df
  })
  
  # Render Cleaned Data Table
  output$cleaned_data <- renderDT({
    req(cleaned_data())
    datatable(cleaned_data())
  })
}

# Run the Shiny App
shinyApp(ui, server)


library(shiny)
library(dplyr)
library(caret)
library(data.table)

# UI for Data Cleaning Module
data_transformation_ui <- function(id) {
  ns <- NS(id)
  
  tagList(
    h3("Data Cleaning and Preprocessing Cont."),
    
    # Scaling (With Options)
    radioButtons(ns("scaling_method"), "Choose Scaling Method:",
                 choices = c("None", "Min-Max Scaling", "Z-score Normalization"),
                 selected = "None"),
    
    # Categorical Encoding
    checkboxInput(ns("encode_categorical"), "Encode Categorical Features (One-Hot Encoding)", FALSE),
    
    # Outlier Handling
    checkboxInput(ns("handle_outliers"), "Handle Outliers (Using IQR)", FALSE),
    conditionalPanel(
      condition = "input.handle_outliers == true",
      ns = ns,
      radioButtons(ns("outlier_method"), "Choose Outlier Handling Method:",
                   choices = c("Cap Outliers", "Remove Outliers"),
                   selected = "Cap Outliers")
    ),
    
    # Apply Cleaning
    actionButton(ns("apply_cleaning"), "Clean and Preprocess Data"),
    
    # Show cleaned data
    h4("Cleaned Data Preview"),
    DT::dataTableOutput(ns("cleaned_data_preview"))
  )
}

# Server Logic for Data Cleaning Module
data_transformation_server <- function(id, cleaned_data) {
  moduleServer(id, function(input, output, session) {
    cleaned_data_final <- reactiveVal()
    
    observeEvent(input$apply_cleaning, {
      req(cleaned_data())
      data <- cleaned_data()
      
      # Scale Numerical Data
      if (input$scaling_method != "None") {
        num_cols <- sapply(data, is.numeric)
        if (input$scaling_method == "Min-Max Scaling") {
          data[num_cols] <- lapply(data[num_cols], function(x) (x - min(x, na.rm = TRUE)) / (max(x, na.rm = TRUE) - min(x, na.rm = TRUE)))
        } else if (input$scaling_method == "Z-score Normalization") {
          data[num_cols] <- lapply(data[num_cols], function(x) (x - mean(x, na.rm = TRUE)) / sd(x, na.rm = TRUE))
        }
      }
      
      # Encode Categorical Features
      if (input$encode_categorical) {
        cat_cols <- sapply(data, is.character) | sapply(data, is.factor)
        if (any(cat_cols)) {
          data <- as.data.frame(model.matrix(~ . - 1, data = data))
        }
      }
      
      # Handle Outliers (With IQR)
      if (input$handle_outliers) {
        num_cols <- sapply(data, is.numeric)
        if (any(num_cols)) {
          for (col in names(data)[num_cols]) {
            Q1 <- quantile(data[[col]], 0.25, na.rm = TRUE)
            Q3 <- quantile(data[[col]], 0.75, na.rm = TRUE)
            IQR <- Q3 - Q1
            lower_bound <- Q1 - 1.5 * IQR
            upper_bound <- Q3 + 1.5 * IQR
            
            if (input$outlier_method == "Cap Outliers") {
              data[[col]][data[[col]] < lower_bound] <- lower_bound
              data[[col]][data[[col]] > upper_bound] <- upper_bound
            } else if (input$outlier_method == "Remove Outliers") {
              data <- data[data[[col]] >= lower_bound & data[[col]] <= upper_bound, ]
            }
          }
        }
      }
      
      cleaned_data_final(data)
    })
    
    # Show Cleaned Data
    output$cleaned_data_preview <- DT::renderDataTable({
      req(cleaned_data_final())
      DT::datatable(cleaned_data_final())
    })
    
    # Return the cleaned dataset
    return(cleaned_data_final)
  })
}

```
